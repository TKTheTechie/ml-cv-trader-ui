/* src/lib/trading-engine/trading-engine.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import Chart from '../../../_snowpack/pkg/svelte-frappe-charts.js';
import { SOLACE_CLIENT_CONTEXT_KEY } from '../solace-client.js';
import { getContext, onMount } from '../../../_snowpack/pkg/svelte.js';

import {
	tickStore,
	signalStore,
	gameOver,
	Signal,
	portfolioStore
} from '../store/store.js';

function create_fragment(ctx) {
	let section;
	let chart;
	let current;

	let chart_props = {
		data: /*data*/ ctx[3],
		type: "line",
		class: "w-full h-full",
		lineOptions: /*lineOptions*/ ctx[1],
		axisOptions: /*axisOptions*/ ctx[2]
	};

	chart = new Chart({ props: chart_props });
	/*chart_binding*/ ctx[4](chart);

	return {
		c() {
			section = element("section");
			create_component(chart.$$.fragment);
		},
		m(target, anchor) {
			insert(target, section, anchor);
			mount_component(chart, section, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const chart_changes = {};
			chart.$set(chart_changes);
		},
		i(local) {
			if (current) return;
			transition_in(chart.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(chart.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			/*chart_binding*/ ctx[4](null);
			destroy_component(chart);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $tickStore;
	let $signalStore;
	let $portfolioStore;
	let $gameOver;
	component_subscribe($$self, tickStore, $$value => $$invalidate(5, $tickStore = $$value));
	component_subscribe($$self, signalStore, $$value => $$invalidate(6, $signalStore = $$value));
	component_subscribe($$self, portfolioStore, $$value => $$invalidate(7, $portfolioStore = $$value));
	component_subscribe($$self, gameOver, $$value => $$invalidate(8, $gameOver = $$value));
	let lineOptions = { hideDots: 1 };
	let axisOptions = { xAxisMode: 'tick' };
	let solaceClient = getContext(SOLACE_CLIENT_CONTEXT_KEY);
	let solaceChart;
	let data = { labels: [], datasets: [{ values: [] }] };

	onMount(async () => {
		solaceClient.subscribe('tkthetechie/price/solly', msg => {
			const blob = new Blob([msg.getBinaryAttachment()], { type: 'text/plain; charset=utf-8' });

			blob.text().then(text => {
				let marketDataEvent = JSON.parse(text);
				tickStore.updateTick(marketDataEvent);
				solaceChart.addDataPoint('', [marketDataEvent.mid]);
			});

			if ($gameOver) {
				console.log('Game over - emptying portfolio at ' + $tickStore.mid);
				solaceClient.unsubscribe('tkthetechie/price/solly');
				if ($portfolioStore.stonks != 0) portfolioStore.sellStonks($portfolioStore.stonks, $tickStore.ask);
			} else {
				switch ($signalStore) {
					case Signal.BUY:
						portfolioStore.buyStonks(1, $tickStore.bid);
						break;
					case Signal.SELL:
						portfolioStore.sellStonks(1, $tickStore.ask);
						break;
					default:
						break;
				}
			}
		});
	});

	function chart_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			solaceChart = $$value;
			$$invalidate(0, solaceChart);
		});
	}

	return [solaceChart, lineOptions, axisOptions, data, chart_binding];
}

class Trading_engine extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Trading_engine;